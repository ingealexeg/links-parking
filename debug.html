// El sistema define la dirección del túnel para la comunicación con el servidor físico Janus
const JANUS_IP = "sympathetic-retha-unsedulously.ngrok-free.dev";
// El script almacena las credenciales de acceso para el servicio de integración de Janus
const CREDENTIALS = { "username": "TasGT25", "password": "Hub$2025" };

// El sistema establece los puntos finales y parámetros de configuración para la pasarela Yappy V2
const YAPPY_UAT_URL = "https://api-comecom-uat.yappycloud.com";
const MERCHANT_ID = "ID_DE_PRUEBAS"; 
const DOMAIN_URL = "https://ingealexeg.github.io"; 
// El motor utiliza esta clave secreta proporcionada por Yappy para la validación de integridad (Hash)
const SECRET_KEY = "TU_CLAVE_SECRETA_AQUI"; 

// El script define las constantes de impuestos y valores fijos requeridos para la orden de cobro
const PORCENTAJE_IMPUESTO = 0.12; 
const ALIAS_YAPPY = "61234567"; 
// Esta es la URL de retorno donde Yappy enviará al usuario después de pagar
const IPN_URL = "https://ingealexeg.github.io/debug.html?ipn=true"; 

/**
 * El sistema genera un identificador único (UUID) para referenciar las transacciones de pago.
 * Esto garantiza que cada solicitud enviada al sistema Janus tenga un rastro único y rastreable.
 */
function generarUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16).toUpperCase();
  });
}

export default {
  async fetch(request, env) {
    // El script configura los encabezados CORS para permitir la interacción segura con el frontend
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
    };

    // El sistema gestiona las solicitudes de tipo OPTIONS para cumplir con las políticas de seguridad del navegador
    if (request.method === "OPTIONS") return new Response(null, { headers: corsHeaders });

    try {
      // El motor analiza el cuerpo JSON de la solicitud enviada por el frontend (debug.html)
      const body = await request.json();
      const { action, ticket, amount, tariffId, nit, hash, status, orderId } = body;

      // --- FASE 1: AUTENTICACIÓN CON EL SERVIDOR JANUS ---
      // El script solicita una sesión activa al servidor Janus para obtener el token de autorización temporal
      const loginRes = await fetch(`https://${JANUS_IP}/janus-integration/api/ext/login`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(CREDENTIALS)
      });
      const loginText = await loginRes.text();
      // El sistema extrae el token de la respuesta XML recibida mediante una expresión regular
      const token = loginText.match(/<value>(.*?)<\/value>/)[1];

      // --- FASE 2: OBTENCIÓN DE DATOS DEL TICKET (getData) ---
      if (action === "getData") {
        // El script consulta al servidor Janus el estado actual del código de barras
        const res = await fetch(`https://${JANUS_IP}/janus-integration/api/ext/payment/get/ticketdata`, {
          method: "POST",
          headers: { "Janus-TP-Authorization": token, "Content-Type": "application/json" },
          body: JSON.stringify({ "mediaTypeIdentifier": "barcode", "ticketIdentifier": ticket })
        });
        const ticketDataXml = await res.text();
        
        // El sistema extrae valores clave del XML como el monto, tiempo de salida y número real del ticket
        const monto = ticketDataXml.match(/<amountToPay>(.*?)<\/amountToPay>/)?.[1];
        const paidTimeValue = ticketDataXml.match(/<paidTime>(.*?)<\/paidTime>/)?.[1] || "";
        const freeExitMins = ticketDataXml.match(/<freeExit>(.*?)<\/freeExit>/)?.[1] || "0";
        const realTicketNum = ticketDataXml.match(/<ticketNumber>(.*?)<\/ticketNumber>/)?.[1] || ticket;

        // El motor determina si el ticket ya fue pagado previamente para evitar cobros duplicados
        if (monto === "0" && paidTimeValue !== "" && paidTimeValue !== "0") {
          return new Response(JSON.stringify({ status: "ALREADY_VALIDATED", remaining: freeExitMins, realTicket: realTicketNum }), 
          { headers: { ...corsHeaders, "Content-Type": "application/json" } });
        }
        // Si no ha sido pagado, el script retorna la información completa del ticket al frontend
        return new Response(ticketDataXml, { headers: corsHeaders });
      }

      // --- FASE 3: APLICACIÓN DEL PAGO EN EL HARDWARE (applyPayment) ---
      if (action === "applyPayment") {
        const montoNum = parseFloat(amount);
        // El sistema genera un UUID solo si el monto es mayor a cero (pago real)
        const uuidFactura = (montoNum > 0) ? generarUUID() : "";
        const nitFinal = (nit && nit.trim() !== "") ? nit.toUpperCase() : "CF";
        
        // El script construye el objeto JSON requerido por la API de Janus para liberar el ticket
        const applyBody = {
          "mediaTypeIdentifier": "barcode", "ticketIdentifier": ticket, "amountToPay": montoNum,
          "calculatedCost": montoNum, "paymentUniqueReferenceId": uuidFactura, "tariffProfileId": parseInt(tariffId),
          "paymentReceiptInfo": { "receiptPaymentMediaIdentifier": "yappy", "receiptUniqueId": uuidFactura }
        };
        
        // El motor envía la instrucción definitiva de liberación al servidor Janus
        const res = await fetch(`https://${JANUS_IP}/janus-integration/api/ext/payment/apply`, {
          method: "POST", headers: { "Janus-TP-Authorization": token, "Content-Type": "application/json" },
          body: JSON.stringify(applyBody)
        });
        const janusResponse = await res.text();
        // El script retorna la respuesta de Janus, el UUID y el NIT procesado al frontend
        return new Response(JSON.stringify({ janusResponse, uuidFactura, nitFinal }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
      }

      // --- FASE 4: CREACIÓN DE ORDEN EN LA PASARELA YAPPY (createYappyV2Order) ---
      if (action === "createYappyV2Order") {
        // El script valida al comercio ante Yappy para obtener un token JWT de sesión
        const authRes = await fetch(`${YAPPY_UAT_URL}/payments/validate/merchant`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ merchantId: MERCHANT_ID, urlDomain: DOMAIN_URL })
        });
        const authData = await authRes.json();
        const yappyJWT = authData.body.token;

        // El sistema limpia el número de ticket para cumplir con el límite de 15 caracteres de Yappy (OrderId)
        let cleanOrderId = ticket.includes('-26') 
                            ? ticket.split('-26')[1].substring(0, 15) 
                            : ticket.replace(/[^a-zA-Z0-9]/g, '').substring(0, 15);

        // El motor realiza los cálculos financieros de subtotal e impuestos (IVA 12%)
        const totalCobrar = parseFloat(amount);
        const calculoTaxes = totalCobrar * PORCENTAJE_IMPUESTO;
        const calculoSubtotal = totalCobrar - calculoTaxes;

        // El script registra la orden de pago en los servidores de Yappy
        const orderRes = await fetch(`${YAPPY_UAT_URL}/payments/payment-wc`, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Authorization": `Bearer ${yappyJWT}` },
          body: JSON.stringify({
            merchantId: MERCHANT_ID,
            orderId: cleanOrderId,
            domain: DOMAIN_URL,
            paymentDate: Math.floor(Date.now() / 1000), 
            aliasYappy: ALIAS_YAPPY,
            // El script inyecta el número de ticket real (sin truncar) en la IPN_URL para recuperarlo después
            ipnUrl: `${IPN_URL}&realTicket=${ticket}`,
            discount: "0.00",
            taxes: calculoTaxes.toFixed(2),
            subtotal: calculoSubtotal.toFixed(2),
            total: totalCobrar.toFixed(2)
          })
        });
        const orderData = await orderRes.json();
        
        // El motor retorna al frontend los tokens necesarios para levantar el componente de pago
        return new Response(JSON.stringify({
          transactionId: orderData.body.transactionId,
          token: orderData.body.token,
          documentName: orderData.body.documentName,
          orderId: cleanOrderId
        }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
      }

      // --- FASE 5: VERIFICACIÓN DE SEGURIDAD (verifyYappyHash) ---
      if (action === "verifyYappyHash") {
        // El script decodifica la clave secreta Base64 y extrae la parte útil del secreto
        const decodedKey = atob(SECRET_KEY); 
        const secrete = decodedKey.split('.')[0]; 
        // El sistema construye la cadena de mensaje original que Yappy usó para firmar
        const message = orderId + status + DOMAIN_URL;

        // El motor criptográfico importa la clave y genera un HMAC-SHA256 local para comparar
        const encoder = new TextEncoder();
        const key = await crypto.subtle.importKey(
            "raw", encoder.encode(secrete),
            { name: "HMAC", hash: "SHA-256" },
            false, ["sign"]
        );
        const signatureBuffer = await crypto.subtle.sign("HMAC", key, encoder.encode(message));
        // El sistema convierte el buffer binario en una cadena hexadecimal
        const localHash = Array.from(new Uint8Array(signatureBuffer))
                               .map(b => b.toString(16).padStart(2, '0')).join('');

        // El script confirma si el hash generado localmente es idéntico al que mandó Yappy
        const isLegit = (localHash === hash);
        return new Response(JSON.stringify({ success: isLegit, status: status }), 
        { headers: { ...corsHeaders, "Content-Type": "application/json" } });
      }

    } catch (e) {
      // El motor captura cualquier excepción y la reporta en formato JSON con código 500
      return new Response(JSON.stringify({ error: e.message }), { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } });
    }
  }
};
